#include "/Engine/Public/Platform.ush"

StructuredBuffer<uint>   InputBuffer	: register(t0);
RWStructuredBuffer<uint> OutPrefixSums	: register(u0);
RWStructuredBuffer<uint> OutGroupSums	: register(u1);
uint NumElements;

groupshared uint SharedData[THREAD_GROUP_SIZE];

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void Main(uint3 GlobalThreadID : SV_DispatchThreadID, uint3 GroupThreadID : SV_GroupThreadID, uint3 GroupID : SV_GroupID)
{
	const uint GlobalThreadIdx = GlobalThreadID.x;
	const uint GroupThreadIdx = GroupThreadID.x;
	const uint GroupIdx = GroupID.x;
	const bool bLastThreadInGroup = GroupThreadIdx == (THREAD_GROUP_SIZE - 1);

	//const uint ScopedThreadIdx = GlobalThreadIdx * TASKS_PER_THREAD;

	// Initialize shared memory
	if (GlobalThreadIdx < NumElements)
	{
		SharedData[GroupThreadIdx] = (GlobalThreadIdx > 0) ? InputBuffer[GlobalThreadIdx - 1] : 0;
	}
	else
	{
		SharedData[GroupThreadIdx] = 0; // Zero out unused threads
	}
	GroupMemoryBarrierWithGroupSync();

	// Compute prefix sum within shared memory
	for (uint Offset = 1; Offset < THREAD_GROUP_SIZE; Offset *= 2)
	{
		uint Temp = 0;
		if (GroupThreadIdx >= Offset && GroupThreadIdx < THREAD_GROUP_SIZE && GlobalThreadIdx < NumElements)
		{
			Temp = SharedData[GroupThreadIdx - Offset];
		}
		GroupMemoryBarrierWithGroupSync();

		if (GlobalThreadIdx < NumElements)
		{
			SharedData[GroupThreadIdx] += Temp;
		}
		GroupMemoryBarrierWithGroupSync();
	}

	// Write back the results to the output buffer
	if (GlobalThreadIdx < NumElements)
	{
		OutPrefixSums[GlobalThreadIdx] = SharedData[GroupThreadIdx];
	}
	else
	{
		OutPrefixSums[GlobalThreadIdx] = 0; // Zero out unused threads
	}

	// Store group sum
	if (bLastThreadInGroup && GlobalThreadIdx < NumElements)
	{
		OutGroupSums[GroupIdx] = SharedData[GroupThreadIdx];
	}
}