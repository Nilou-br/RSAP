Generation:

	Variables:

		// DefaultDepth: Integer deciding what the MaximumDepth should be for the whole octree outside of the players LOD distance. ( Limit this variable to some extent. )
		// MaxDepth: Maximum depth for the octree, the highest resolution layer will be generated close to the player. ( Also limit this variable to some extent. )
		LODs: Lowest LOD is the DefaultDepth, highest is the MaximumDepth. Determines the depth of close voxels.
		StaticVoxelSize: Unsigned long long, default voxel size, used for static meshes with no dynamic object or player nearby.
		MinVoxelSize: Unsigned long long, size of the voxel at the lowest depth in the tree, used for more precision near the player and dynamic objects.
		CollisionBoxes: list of collision-boxes (FCollisionShape::MakeBox), one for each layer in the SVO, that will be used to check if a given node is occluded.

	Instruction:

		Generate chunks in such a way so that their centers align with world-coordinate 0,0,0; So that there exists a chunk encompassing the world-center ( if there are any objects placed there which is likely ).
		( chunk-size should be so that a grid of 3x3x3 chunks around the player will cover the whole distance. Or some other better value. )

		Chunks ( or the FOctree ) will have a local-coordinate starting from its negative most corner which is used to know the location of children inside the octree.
		Child nodes will have their morton-code generated relative from this chunk's local-coordinate.

		Child nodes are recursively generated starting from the corner closest to the root's local coordinate, and inserted into the layers array in morton-code order.
		Recursive method should be run in such a way so that every node insertion into a layer will be in perfect morton-code order.

		Store the chunks in a TMap so we can find them by their coordinates. Find a specific chunk by (player-location / chunk-size) - chunk-extent? ( Find out how to get specific chunk).
		Create a list of collision-boxes (FCollisionShape::MakeBox), one for each layer in the SVO, that will be used to check if a given node is occluded.


		For each chunk:
			
 			Start at the root node:
			Call a recursive method that checks the passed in node if it occludes anything using 'OverlapBlockingTestByChannel' with the correct 'voxel-size' from the VoxelSizes array for that layer.

			If the node occludes anything:
			Subdivide into 8 children and use the same recursive method on each child; Repeat until max-depth is reached which simply returns directly at the start of the recursive method.	

			




Dynamic updates:
	
	Info:
		
		The player and Dynamic Objects have a certain radius around them which makes the nodes within that radius higher resolution.

		Nodes store pointers instead of variables to neighbours (maybe also to children and parent).
		This does increase memory usage, but because only the nodes around dynamic objects are of higher resolution, and the rest of the SVO is lower resolution, it won't be a big impact
 		unless there are a lot of dynamic objects. A normal link node would be 40 bytes, compared to 72 bytes when using pointers ( on 64 bit OS ).

		Dynamic objects will use their bounding box as affected area. When they move, they will notify the WorldNavigationSubsystem, which will use another class to update everything in batches every so often.
		How often it updates will depend on how far away the dynamic objects are from the player.
